
<!-- 
# pos-service
dotnet ef migrations add message
dotnet ef database update
-->

# 🛒 POS Backend Service Technical Architecture

This repository hosts the backend service for a Point of Sale (POS) system, built on ASP.NET Core Web API. The service is designed to be a robust, scalable, and secure microservice managing core business domains like Inventory, Sales, and User Management.

## 💡 Core Design Principles

The application adheres to the Clean Architecture principles, maintaining a strict separation of concerns to ensure modularity, testability, and maintainability.

### Layers

- **Presentation (Controllers)**: Handles HTTP requests, authentication, authorization, and maps requests to application services.
- **Application (Services)**: Contains the core business logic, orchestrates data flow, and manages transactions. Interfaces are defined here.
- **Infrastructure (Repositories/Data/Security)**: Handles external concerns such as database access (EF Core), file storage, and security implementations (Hashing/JWT).
- **Domain (Models/Enums)**: Contains core business entities and value types, independent of any specific framework.

### Technologies

| Aspect | Technology/Pattern Used |
|--------|------------------------|
| Framework | ASP.NET Core Web API |
| Database Access | Entity Framework Core (EF Core) |
| Mapping | AutoMapper (for Entity ↔ DTO projection) |
| Dependency Management | Inversion of Control (IoC) via built-in Dependency Injection |
| Authentication | JWT Bearer Tokens (Stateless, Token-Based Security) |
| Security | PBKDF2 Hashing via PasswordHasher for password storage |

## 🔐 Solution Components & Security

### User Management (UsersController, UserService, UserRepository)

The user subsystem is designed for high security and controlled access:

- **Role-Based Access Control (RBAC)**: Access to endpoints is strictly enforced using `[Authorize(Roles = ...)]` or Authorization Policies (e.g., SalesTeamAccess). Roles are derived from the UserRole enum (e.g., SystemAdmin, Cashier).
- **Secure Authentication Flow**:
  - User sends credentials to `/api/users/login` (UserLoginReqDto).
  - UserService verifies the password using the secure IPasswordHasher.
  - A signed JWT (JSON Web Token) is generated by the IJwtGenerator containing user claims (ID, Username, and Role).
- **Password Storage**: Passwords are never stored in plain text. They are hashed using a salted, iterative hashing algorithm (PBKDF2) provided by PasswordHasherService.
- **Soft Delete**: User deactivation (`/deactivate`) uses a soft delete approach (`IsActive = false`) for auditing purposes. Hard delete is reserved for critical cleanup.

### File Handling and Storage (Profile Images)

The service handles file storage internally rather than relying on external URLs for profile pictures:

- **Data Flow**: The client sends the user data as a JSON body, and the file path as a string (ProfileImagePath).
- **File Copy**: The IFileStorageService implements the CopyAndSaveFileAsync logic, securely copying the file from the designated source path to the application's local Content Root Directory (not wwwroot).
- **Path Storage**: Only the relative URL/path (e.g., `/uploads/users/profiles/image.jpg`) is saved in the User.ProfileImageUrl field, not the file contents (Base64) or the external path.
- **Deletion Cascade**: When a user is permanently deleted, the UserService ensures the associated file is also deleted from disk via IFileStorageService.DeleteFile().

## 📦 Data Structure and Domain Modeling

### Item and Inventory

The ItemsController provides comprehensive access to inventory with multi-key support:

- **Composite Key**: Items are identified by a composite key (Id and SubId) to manage variants (e.g., shirt color/size variations of a single product).
- **Barcode Lookup**: Direct lookups are supported by barcode (`/api/items/barcode/{barCode}`).
- **Relationships**: Items maintain a many-to-many relationship with Suppliers via a linking table (implicitly or explicitly managed by EF Core).

### Sales/Order Management (Order, OrderItem)

The sales domain is designed for transaction integrity and historical reporting:

- **One-to-Many Relationship**: A single Order (receipt/transaction header) holds multiple OrderItem records (line items), representing a standard sales model.
- **Data Snapshotting (Denormalization)**: The OrderItem model includes crucial fields (ItemPrintName, PriceAtSale, CostAtSale, DiscountRatioAtSale) copied from the Item table at the time of sale. This is vital for accurate reporting (P&L) even if the original item's price changes later.
- **Auditing**: Both Order and OrderItem inherit from IAuditable, ensuring every transaction records its CreatedAt, CreatedBy, and Uuid.
